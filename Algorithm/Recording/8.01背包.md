# **01背包**



问题：

一个容量为m公斤的背包。现有n种物品 ，**每种物品只有一件**，它们的重量分别为：$W_i(1<= i <= n)$，它们的价值分别为：$C_i(1<=i<=n)$。求能放入背包的最大价值。

输入：

第一行：两个整数，n（物品数量，n<51）和 m(背包容量，m<210)。

第2……n+1行：每行两个整数$W_i和C_i$，表示每个物品的重量和价值。

输出：

一个数，表示最大价值。

输入样例：

**3 6**
3 5
2 3
4 6

输出样例：

9

---



使用的算法：*动态规划算法*

由题目可以观察到重量越大，相应的价值也就越大。



状态变量：f[i]\[j] 表示前 i 件物品放入容量为 j 的背包的最大价值。

分析状态转移方程：

1. 如果第 i 件物品大于容量为 j 的背包，不能放入背包，则f[i]\[j] = f[i - 1]\[j]
2. 如果第 i 件物品小于等于容量为 j 的背包，则：
   1. 如果第 i  件物品不放入背包，则:f[i]\[j] = f[i - 1]\[j] 
   2. 如果第 i 件物品放入背包，则：f[i]\[j] = f[i - 1]\[j - w[i]] + c[i] (表示先找到第此时背包容量减去第i件物品时的价值并且没有放第i件物品（因为要留足够的空间来放置 第 i 件物品），然后再加上第 i 件物品的价值，其中 w[i] 表示第 i 件物品的重量， c[i] 表示第 i 件物品的价值)。

- 由以上分析可以进一步得到，如果第 i 件物品小于等于容量为 j 的背包 ，则f[ i ]\[ j ] = max(f[i - 1]\[j]，f[i]\[j - w[i]] + c[i]);意思是：取放入该物品所得到的价值与不放该物品所得到的价值的最大值。

> 思考：如果第 i 件物品放入背包，为什么不是 f[i]\[j] = f[i]\[j - w[i]] + c[i] ？
>
> 解答：因为如果是f[i]\[j] = f[i]\[j - w[i]] + c[i] ，则有可能放入多个第i件物品，但是题目要求每种物品只有一件，因此不能是这样。

确定状态转移方程：

1. **if(w[i] > j)   f[i]\[j] = f[i - 1]\[j]**
2. **else f[ i ]\[ j ] = max(f[i - 1]\[j]，f[i - 1]\[j - w[i]] + c[i])**



定义边界：当i = 0或者 j = 0 的时候，此时的f[i]\[j] = 0，因为此时的价值为0 。

图表举例：

|       | 1    | 2    | 3    | 4    | 5    | 6    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- |
| **3** | 0    | 0    | 5    | 5    | 5    | 5    |
| **2** | 0    | 3    | 5    | 5    | 8    | 8    |
| **4** | 0    | 3    | 5    | 6    | 8    | 9    |

表格说明：第一行表示背包的容量，第一列表示物品的重量。中间未加粗的值表示背包容量为j时，能放入从1~i个物品的最大价值 。
如：i = 2，j = 3表示背包容量为3，能放入物品重量为3和2的最大价值



代码实现：

```cpp
for(i = 0;i<=n;i++){
    for(j = 1;j<=m;j++){
	if(j < w[i]) f[i][j] = f[i -1][j];
     else f[i][j] = max(f[i -1][j],f[i -1][j - w[i]]+c[i])
    }
}
cout<<f[n][m];
```

<center> 时间复杂度：O(nm) ; 空间复杂度：O(nm)

---

### 优化空间复杂度

使用一维数组f[m]来进行记录状态，并在f[i] 的基础上更新状态。

状态转移方程：

1. **if(w[ i ] > j)   f[ j ] = f[ j ]**
2. **else f[ i ] = max(f[ j ]，f [ j - w[ i ]] + c[ i ])**

这样得到一个问题，就是如果按照此状态转移方程执行的话，会导致f[ j  - w[i]] 先更新（因为f[ j - w[i]] 在f[i] 之前），进而造成在背包容量为i的情况下，可能会有多个相同的物品放入该背包，举例：如果此时的背包容量为i = 2，j = 4，则f[2] = 3; f[4] = max(f[4],f[4 - 2] + c[2]) ;因为此时的f[4]是i = 1时的f[4] (还未更新)，f[4] = 5; f[4 -2] + c[2] = f[2] + c[2] = 3 + 3 = 6，因此f[4] = 6，这显然时不正确的，因为如果这样取值会导致在背包中放入两次 重量为2的物品。

如何解决？
通过分析可以知到，导致放入两次重量为2的物品是因为 f[ j - w[i] ] 先于f[ j ]更新 ，我们可以通过从后向前遍历，使 f[ j ] 先于  f[ j - w[i] ] 跟新。

定义边界：f[0~m] = 0;



代码实现：

```cpp
for(i = 0;i<=n;i++){
    for(j = m;j>=1;j--){
	if(j < w[i]) f[j] = f[j]
     else f[j] = max(f[j],f[j - w[i]]+c[i])
    }
}
cout<<f[m];
```

<center> 时间复杂度：O(nm)  ;空间复杂度O(m)

更简洁的写法：

```cpp
for(i = 0;i<=n;i++)  //物品i
    for(j = m;j>=w[i];j--)  //容量j
     	f[j] = max(f[j],f[j - w[i]]+c[i])
cout<<f[m];
```

<center> 时间复杂度：O(nm)  ;空间复杂度O(m)

可以看到 j 值每循环一遍，f[ j ]就滚动更新一遍，因此也把f[ j ]称为滚动数组。