# **二叉树的遍历**

## 1.先序遍历

遍历过程：

1. 访问根节点；
2. 先序遍历其左子树；
3. 先序遍历其右子树

``` cpp
void PreOrder(BiTree BT){
	if(BT){ //如果BT不为空
		printf("%c",BT->Data);   //访问节点
        PreOrder(BT->Left);    //递归调用左子树
        PreOrder(BT->Right);   //递归调用右子树
    }
}
```

在递归调用节点的儿子节点之前访问该节点

---

## 2.中序遍历

遍历过程:

1. 中序遍历其左子树
2. 访问根节点
3. 中序遍历其右子树

```cpp
void InOrder(BiTree BT){
	if(BT){ //如果BT不为空
        InOrder(BT->Left);    //递归调用左子树
        printf("%c",BT->Data);   //访问节点
        InOrder(BT->Right);   //递归调用右子树
    }
}
```

每当走到节点的底部时进行输出，当节点需要转折时进行访问节点

---

## 3.后序遍历

遍历过程：

1. 后序遍历其左子树
2. 后序遍历其右子树
3. 访问根节点

```cpp
void PostOrder(BiTree BT){
	if(BT){ //如果BT不为空
        PostOrder(BT->Left);    //递归调用左子树
        PostOrder(BT->Right);   //递归调用右子树
        printf("%c",BT->Data);   //访问节点
    }
}

```

当递归调用完节点的所有儿子节点时，就进行访问该节点。

---

## 4.推断二叉树

根据先序和中序遍历序列确定一颗二叉树的步骤：

1. 根据先序序列的第一个结点确定根节点；
2. 根据根结点在中序序列中的位置，分割出左子树和右子树；
3. 对左子树和右子树分别递归使用相同的方法继续分解；

根据后序和中序遍历序列确定一颗二叉树的步骤：

1. 根据先序序列的最后一个结点确定根节点；
2. 根据根结点在中序序列中的位置，分割出左子树和右子树；
3. 对左子树和右子树分别递归使用相同的方法继续分解；

**已知先序和后序遍历序列，不能确定一颗二叉树！**