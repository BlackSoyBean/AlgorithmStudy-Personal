# **最长公共子串**

题目描述：

给定两个字符串，输出其最长的公共子串的长度。

输入：ABACCB 与 AACCAB

输出：3

解释：最长公共子串是ACC，其长度为3。

> 区别：**与最长公共子序列不同，最长公共子串是一段连续的字符串**

---

使用的主要算法是：*动态规划算法。*

用 **i** 遍历第一个字符串，用 **j** 遍历第二个字符串，并且原问题转换为以第 i 个字符结尾与第 j 个字符结尾的字符串的公共子串，有以下两种情况，如果第 i 个字符与第 j 个字符相等则 = f[ i - 1 ]\[ j - 1 ] + 1，否则 f[ i ]\[ j ] = 0；  因为如果第 i 个字符与第 j 个字符不匹配，则以该字符结尾的字符一定不是公共子串，故赋值为0，然后再往后判断，如果后面的字符f[ i  + 1]\[ j + 1 ]相等，则f[ i  + 1]\[ j + 1 ] = f[ i ]\[ j ] + 1 。



最后只需输出f[ n ]\[ m ] 即可，n，m分别代表两个字符串的长度。

进阶：输出最长公共子串，可以这样思考，我们只需要记录最长公共子串的最后一个位置，即最长公共子串的大小不在改变，然后向前遍历最长公共子串的长度次即可输出最长公共子串的逆序，然后再反向输出即可得到最长公共子串。

如果用数学符号代表：len：表示最长公共子串的长度，pos：表示最长公共子串的大小。可以遍历第一个字符串（第二个字符串也可以），从len - pos + 1个位置开始，向后遍历len次即可得到最长公共子串。

----

*代码实现：*

```cpp 
//最长公共子串
#include<iostream>
#include<string>
using namespace std;
//定义各个状态的数组
int f[101][101];
int per = -1; //用于指向最长公共子串的最后一个元素 

int DP(string t1,string t2){
	int M_E = 0,MM = 0;
    //分别遍历两个字符串
	for(int i = 1;i<=t1.size();i++){
		for(int j = 1;j<=t2.size();j++){
			if(t1[i-1] == t2[j-1]){  //因为字符串的下标从0开始，判断第i个字符是否等于第j个字符
				f[i][j] = f[i-1][j-1] + 1;
				//更新此时的最大值
				MM = max(M_E,f[i][j]); 
				if(MM > M_E){  //如果此时的最大值更新后，则记录此时的位置。
					M_E = MM;
					per = i-1;	//记录最长子串的最后一个元素
				} 
			}else{
				f[i][j] = 0;
			}
		}
	}
	
	return M_E;
}
//输出最长子串
void pt(string t1,int len){
	int i = per,j = len;
	for(int i = per - len + 1;i<=per;i++){
		cout<<t1[i]<<" ";
	}
} 
int main(){
	string text1 = "ABACCB";
	string text2 = "AACCAB";
	int answer = DP(text1,text2);
	cout<<"最长公共子串为："<<answer<<endl;
	pt(text1,answer);
	return 0;
} 
```



