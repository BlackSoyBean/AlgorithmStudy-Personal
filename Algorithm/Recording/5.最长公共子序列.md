# **最长公共子序列**



**题目描述：**

**给定两个字符，输出其最长公共子序列的长度。**

**输入**：A**D**A**B**E**C** 与 **DB**D**C**A

**输出：3**

**解释：最长公共子序列是*DBC*，其长度为3**

使用的算法：*动态规划算法。*

思路：可以这样思考，i 用于遍历第一个字符串，j 用于遍历第二个字符串。第 i 个字符与第j 个字符之前的最大公共子序有以下情况：

1. 如果第i个字符等于第 j 个字符，则第f[i] [j] = f[i - 1]\[ j - 1] + 1
2. 如果第i个字符与第j个字符不相等，且第i个字符不在公共子序列中，可以去掉第i个字符，则第f[i] [j] = f[i - 1] [j] ;    
3. 如果第i个字符与第j个字符不相等，且第j个字符不在公共子序列中，可以去掉第j个字符，则第f[i] [j] = f[i] [j -1] ；

|      | A    | D    | A    | B    |
| ---- | ---- | ---- | ---- | ---- |
| D    | 0    | 1    | 1    | 1    |
| B    | 0    | 1    | 1    | 2    |
| D    | 0    | 2    | 2    | 2    |
| C    | 0    | 2    | 2    | 2    |

解释：第一层匹配代表第二个字符串的第一个字符与第一个字符串所有字符的匹配情况：如（1，1）表示A与D的最长公共子序列，(1,2)表示AD与D的最长公共子序列，（1 ， 3）表示ADA与D的最长公共子序列，（2，3）表示ADA与DB的最长公共子序列 = max（ADA 与 D的最长公共子序列 ，AD与DB的最长公共子序列）（如果此时不匹配的话）或者 = 在匹配第（2，3）个字符之前的最长公共给子序列+1（如果此时匹配的话）。具体来说：如果第i个字符与第j个字符匹配，则回退到第i - 1与 j - 1个位置（即回退到还没有匹配第i个字符与第j个字符的时候的位置），取该位置的最长公共子序列，然后+1；如果第i个字符与第j个字符不匹配的话，则取第 （i - 1，j）与第（i，j-1）位置的最大值，因为此时可能是第i个字符不是最长公共子序列中的元素，也可能是第j个字符不是最长公共子序列中的元素，如果都不是，则仍然是这两种情况。

**递推式（状态转移方程）：**

f[i]\[j] = f[i - 1]\[j - i] + 1	,a[i] == b[j]

f[i]\[j] = max(f[i - 1]\[j],f[i]\[j - 1]) 	,a[i] != b[j] 

**边界条件：**

f[0]\[j] = 0;

f[i]\[0] = 0;



```cpp
```

