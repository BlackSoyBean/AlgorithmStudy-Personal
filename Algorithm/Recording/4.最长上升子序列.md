# **最长上升子序列**

## 1.动态规划法

**题目描述：**

给定一个无序的整数数组，找出其中最长上升子序列（LIS）的长度。

输入：[5,7,1,9,4,6,2,8,3]

输出：4

解释：最长上升子序列是[1,4,6,8]，其长度是4

---

思路：从前向后进行遍历，设置两个指针i和j，i用于给当前指向的值赋予最长上升子序列，并表示以 i 和 j 结尾的序列，j用于从前向后比较，如果第j个数的值小于第i个数，且第j个数的最长上升子序列+1大于第i个数此时的最长上升子序列，将第i个数的最长上升子序列赋值为第j个数的最长上升子序列+1。	**j个数的最长上升子序列+1是因为第i个数的数值大于第j个数的数值，如果将第j个数当作第i个数的一个子序列，则要在第j个数为结尾的数的基础上+1**

状态变量：

f[i] 记录以a[i]为结尾的最长上升子序列长度。

**初始条件：f[i] = 1**   这表示初始的每一个值都至少是一个最少上升子序列

递推式：

如果(a[i] > a[j] && f[j] + 1>f[i])

则 f[i] = max(f[i] ,f[j] + 1)

**此递推式可以写为：**

**如果：（a[i] > a[j]）,**

**则： f[i] = max(f[i] , f[j] + 1) ,1 <= j < i**

*递推式的特点：*

*(1) : 由小推大 	（最优子结构）*

*(2): 由过去推现在 	(无后效性)*

```cpp
	/*主要算法*/
	int ans = 1;

	//初始化f[i]
	for(int i = 1;i <= n;i++){
		f[i] = 1;
	}

	//动态更新f[i]
	for(int i = 2;i <= n;i++){
		for(int j = 1;j<i;j++){
			if(a[i] > a[j]){
				f[i] = max(f[i],f[j] + 1);  //更新此时的最大子序列 
			}
			ans = max(ans,f[i]);	//记录最大的子序列 
		}
	} 
```

<center> 时间复杂度为$O(n^2)$
---

## 2.二分优化

> 如果把内层循环改为二分查找，就能把内层查找时间降为O(n log n)。但是**二分查找的前提是有序序列**，故增加一个b数组，用来记录上升子序列。
>
> **关键问题：动态更新b数组。**

添加一个b数组后，初始赋值b[1] = a[1]，代表此时的第一个元素，如果后来添加的元素x大于此时b的末尾元素，就将该元素添加到b的末尾，否则就替换掉第一个大于等于x的位置，因为替换掉后并不改变b的长度，即此时的最大子序列并没有改变，但是替换时可能会将末尾元素进行替换，这样做可能会有更大的潜力使b数组更长，有更大的潜力来得到更长的b数组（即有更大的潜力来得到最大子数组）。

### 二分模板

```cpp
int find(int x){
    //二分查找第一个大于等于x的位置
    int L = 1,R = len,mid;   //分别定义左右两个边界
    while(L <= R){
        mid = (L + R)/2;	//中间值
        if(x>b[mid]) L = mid + 1;	//更新左边界
        else R = mid - 1;		//更新右边界
    }
    return L;
}
```



### 更新b数组

```cpp
len = 1;
b[1] = a[1];
//动态更新b数组
for(i = 2;i <= n;i++){
	if(a[i]>b[len])
        b[++len] = a[i];
    else{
        j = find(x);	//找到第一个大于等于x的位置
        b[j] = a[i];
    }
}
pirntf("%d\n",len);		//输出b数组的长度
```

<center>时间复杂度：$O(n\log n)$

