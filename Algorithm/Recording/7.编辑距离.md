# **编辑距离**



**题目：**

字符串编辑距离就是从一个字符串修改到另一个字符串时，编辑单个字符（比如修改、插入、删除）所 需要的最少次数 。俄罗斯科学家Vladimir Levenshtein 于 1965年提出了这一概念。
	从字符串"NOTV"修改为字符串"LOVER"需4次单字符编辑操作：
		LOTV (N改为L)
		LOV (删除T)
		LOVE (插入E)
		LOVER (插入R)
因此"NOTV"和"LOVER"的编辑距离为4。

问题：输入两个字符串a、b，输出从字符串a修改到字符串b时的编辑距离。

输入：a = "NOTV"，b = "LOVER"。

输出：4

---

这是一个最优解问题，可以考虑*动态规划算法*

状态变量：设f[i]\[j] 表示从a[1……i]到b[1……j]的编辑距离。

因为要将字符串a修改为字符串b，所以可以将b作为主串，然后对字符串a进行修改（包括修改、插入、删除 ）。

1. 若a[i] = b[j] ，则 f[ i ]\[ j ]  = f[i - 1]\[j -1]      (表示如果a的第i个字符于b的第j个字符相等，则不需要进行修改操作，直接赋值为前面的值)
2. 若a[i] != b[j] ，
   1. 如果需要对a[i]修改，则f[ i ]\[ j ] = f[i -1]\[j -1] + 1
   2. 如果需要a[i]插入，则f[ i ]\[ j ]  = f[i]\[j -1] + 1
   3. 如果需要a[i]删除，则f[ i ]\[ j ]  = f[i - 1]\[j - 1] + 1

状态转移方程：

if a[i] = b[j] 则 f[ i ]\[ j ]  = f[i - 1]\[j - 1] + 1
else f[ i ]\[ j ]  = min(f[i -1]\[j -1]，f[i]\[j -1]，f[i - 1]\[j - 1]) +1

边界条件：

f[ i ]\[ 0 ] = i;
f[ 0 ]\[ j ] = j;  	

(因为如果有一个字符串为0，修改为另一个字符串（或者另一个字符串修改为0）都需要执行另一个字符串长度次插入（或删除）操作)



图表举例：

| 修改 ：f[i -1]\[j -1]  | 删除：f[i - 1]\[j - 1] |
| :--------------------: | :--------------------: |
| **插入 ：f[i]\[j -1]** |    **f[ i ]\[ j ]**    |

<center>图表1



|             | 字符串a |  L   |  O   |  V   |  E   |  R   |
| :---------: | :-----: | :--: | :--: | :--: | :--: | :--: |
| **字符串b** |    0    |  1   |  2   |  3   |  4   |  5   |
|    **N**    |    1    |  1   |  2   |  3   |  4   |  5   |
|    **O**    |    2    |  2   |  1   |  2   |  3   |  4   |
|    **T**    |    3    |  3   |  2   |  2   |  3   |  4   |
|    **V**    |    4    |  4   |  3   |  2   |  3   |  4   |

<center>图表2

**图表1对应于图表2**

---

*代码实现：*

```cpp
m = strlen(a);
n = strlen(b);
for(i = 1;i<=m;i++) f[i][0] = i;
for(j = 1;j<=n;j++) f[0][j] = j;
for(i = 1;i<=m;i++)
    for(j = 1;j<=n;j++){
		if(a[i-1] == b[j - 1])
            f[i][j] = f[i -1][j - 1];
        else
            f[i][j] = min(f[i - 1][j - 1],min(f[i - 1][j],f[i][j - 1])) + 1;
    }
printf("%d\n",f[m][n])
```

<center> 时间复杂度O(mn) ;空间复杂度O(mn)



优化空间复杂度——使用滚动数组

修改图表1可得

| 修改：t1           | 删除:更新前f[ j ] |
| ------------------ | ----------------- |
| **插入：f[j - 1]** | **更新后f[ j ]**  |



```cpp
m = strlen(a);
n = strlen(b);
for(j = 1;j<=n;j++) f[j] = j;
for(i = 1;i<=m;i++){
    t1 = f[0]++;  //t1等价于f[i - 1][0]
    for(j = 1;j<=n;j++){
        t2 = f[j];
		if(a[i-1] == b[j - 1])
            f[j] = t1;
        else
            f[j] = min(t1,min(f[j - 1],f[j])) + 1;
        t1 = t2;	//t1等价于f[i - 1][j - 1]
    }
}
printf("%d\n",f[n])
```

<center>时间复杂度为O(nm) ; 空间复杂度为 O(n)