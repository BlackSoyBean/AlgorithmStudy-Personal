# **数字三角形问题**

**数塔：**

| 0     | 1    | 2    | 3    | 4    |
| ----- | ---- | ---- | ---- | ---- |
| **1** | *1*  |      |      |      |
| **2** | *4*  | *6*  |      |      |
| **3** | *8*  | *3*  | *9*  |      |
| **4** | *5*  | *7*  | *2*  | *1*  |

## 1.记忆化搜索法

寻找最大路径

```cpp
int f[9][9];	//记录从下向上的累加和
int dfs(int x,int y){
    //记忆化搜索，避免进一步递归(相当于一个备忘录，先从备忘录中寻找，否则进行递归)
    if(f[x][y] != 0) return f[x][y];
	if(x == 1)//边界条件
        f[x][y] = a[x][y];
	else
        f[x][y] = a[x][y] + max(dfs(x+1,y),dfs(x+1,y+1));  //寻找子树中更大的一个进行累加
    return f[x][y]
}
```

记忆化搜索：对递归做了剪枝，搜索过的子树不再重复搜索，直接返回存储值。

时间复杂度计算：因为做了剪枝处理，每个数值只进行一次搜索且在常数范围内完成。$O(N^2) = 1 + 2 + 3 + \cdots+n = \frac{n(n+1)}{2}$ ;



---

## 2.动态规划——数字三角形

*逆推法*（即：动态规划法）

> 递推式：**a[x]\[y] = max(a[x + 1]\[y] , a[x + 1]\[ y + 1]) + a[x]\[y]** 
>
> 在动态规划中，上述递推式即状态转移方程



```cpp
int n = 4;
int a[9][9] = {{1},
				{4,6},
				{8,3,9},
				{5,7,2,1}};  
int main(){
	int x,y;
    //向上逐层累加
    for(x = n - 2;x>=0;x--){  //从倒数第二行开始向上进行累加
		for(y = 0;y<=x;y++){
			a[x][y] = max(a[x + 1][y] , a[x + 1][ y + 1]) + a[x][y];
        }
    }
    //输出数塔最大值
    cout<<"max = "<<a[0][0]<<endl;
    return 0;
}
```

*输出最大和的路径：*

> 前驱路径数组：p[x]\[y]
>
> 备份数组： b[x]\[y]

```cpp
int n = 4;
int a[9][9] = {{1},
				{4,6},
				{8,3,9},
				{5,7,2,1}};  
int b[9][9]; //用于备份
int p[9][9]; //记录路径
int main(){
	int x,y;
    //备份数组，起点（0，0）
    for(x = 0;x < n;x++)
        for(y = 0;y <= x; y++)
            b[x][y] = a[x][y];
    //向上逐层累加
    for(x = n - 2;x >= 0;x--)
        for(y = 0;y <= x;y++)
            if(a[x + 1][y] > a[x + 1][y + 1]){
				a[x][y] += a[x+1][y];
                p[x][y] = 0;	//向下
            }else{
                a[x][y] += a[x + 1][y + 1];
                p[x][y] = 1;  //向右下    相当于记录y的增量，即是否向右移动了。
            }
    //输出数塔最大值
    cout<<"max = "<<a[0][0]<<endl;
	for(x = 0,y = 0;x<n - 1;x++){
		cout<<b[x][y]<<"->";
        y = y + p[x][y];	//下一行的列数
    }
	cout<<b[n-1][y];
	return 0;
}
```



**作业：请你改造顺推法的代码，输出最大和的路径。**
